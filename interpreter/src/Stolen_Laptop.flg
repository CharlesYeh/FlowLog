// Campus police reports mac addresses of stolen laptops
// This just naively looks at the mac of every packet, and spams the police if 
// a stolen laptop is seen (and when). More sophisticated example would get notification
// from NIB that a new host has connected.

// TODO: also will tell the police sequence of _switches_ the mac is seen on. Not necessarily
// only the one connected via an external port. How can we get external ports in an EDB?

blackbox BBtimer @ 127.0.0.1 9091;
blackbox BBpolice @ 127.0.0.1 5050; // (The 5-0)

// IMPORTANT: when reporting a laptop stolen, need to convert mac to a number. 
// e.g. notify stolen_laptop_report mac=1
// to report 00:00:00:00:00:01 stolen. we don't convert types yet.

// Should get all notifs declared in Canary (and in Mac_Learning since Canary imports Mac_Learning)
import Mac_Learning;

module Stolen_Laptop:

type stolen_laptop_report = {mac};
type stolen_laptop_cancel = {mac};
type stolen_laptop_found = {mac,swid,time};

type start_timer = {seconds, id};
type timer_expired = {id};

forward(pkt : packet, newpkt : packet) :- Mac_learning.forward(pkt, newpkt);

+stolen(report: stolen_laptop_report, mac) :- report.mac = mac;

// TODO
// Can't do this right now; we hit the interpreter's lack of type sensitivity on evaluation
//-stolen(cancel: stolen_laptop_cancel, mac) :- cancel.mac = mac;

// Will currently call timer for EVERY PACKET, not just stolen ones.
// Obvious room for improvement.
BBpolice(pkt : packet, found: stolen_laptop_found) :- 
  stolen(pkt.dlSrc), found.mac = pkt.dlSrc, found.swid = pkt.locSw, BBTimer.time(found.time),
  not ratelim(found.mac, any);

// Rate limit spam of police tipline
// interesting problem here: need same nonce. but nonce not generated until AFTER notifications fire!
// so there is a delay of one packet...
// PARSER: can't use packet for packet name.
// LACK OF ERR MSG: Timer vs. BBTimer should say unknown module. But silently fails
+ratelim(pkt : packet, mac, nonce) :- not ratelim(mac, any), BBTimer.nonce(nonce), pkt.dlSrc=mac;
// Need to prevent this from firing AGAIN and AGAIN. Use fact that +/- after notifs
BBtimer(pkt : packet, st: start_timer) :- not timersent(nonce), ratelim(pkt.dlSrc, nonce), st.id = nonce, st.seconds = 10;
+timersent(pkt: packet, nonce) :- ratelim(pkt.dlSrc, nonce); 

-ratelim(ev : timer_expired, mac, nonce) :- ratelim(mac, nonce), ev.id = nonce;
// don't need -timersent


// (1) Do flows belong here instead of packets? 
//  1a: rephrase in terms of flows. (may not be valid flowlog)
//  1b: what if we have flowtags in the headers? what then?

// (2) for arp cache, can payload manip itself be handled by an internal blackbox?

// possible other solns:
// -- 2-stage soln (here)
// -- "closure" event (not the right name) [this is a broader topic]
// -- for THIS problem, don't nonce and just use mac addr. but doesn't generalize.
//   ^^ this may go into the flow-level version